""" Internal utilities for other modules here
"""

import operator as op
from fractions import Fraction


def _delta(i, j):
    return Fraction(int(i == j), 1)


class NotInSpanError(ValueError):
    pass


def _rowReduction(matrix):
    # following the pseudo-code on:
    # https://rosettacode.org/wiki/Reduced_row_echelon_form
    rowCount = len(matrix)
    columnCount = len(matrix[0])
    lead = 0
    reduced = matrix.copy()
    for r in range(0, rowCount):
        if lead >= columnCount:
            break
        i = r
        while not reduced[i][lead]:
            i += 1
            if i == rowCount:
                i = r
                lead += 1
                if lead == columnCount:
                    rank = 0
                    for row in reduced:
                        if not all([x == 0 for x in row]):
                            rank += 1
                    return (reduced, rank)
        reduced[i], reduced[r] = reduced[r], reduced[i]  # swapping rows
        if reduced[r][lead]:
            reduced[r] = [val/reduced[r][lead] for val in reduced[r]]
        for i in range(0, rowCount):
            if i != r:
                reduced[i] = list(
                    map(
                        op.sub,
                        reduced[i],
                        [val*reduced[i][lead] for val in reduced[r]]
                    )
                )
        lead += 1
    # end of row reduction
    rank = 0
    for row in reduced:
        if not all([x == 0 for x in row]):
            rank += 1
    return (reduced, rank)


def _matMult(A, B):
    if not A or not B:
        raise ValueError("Cannot multiply empty matrices.")
    rowsA, columnsA = len(A), len(A[0])
    rowsB, columnsB = len(B), len(B[0])
    C = _zeroMatrix(rowsA, columnsB)
    if columnsA != rowsB:
        raise ValueError((f"Matrices of size {rowsA}x{columnsA} and "
                          f"{rowsB}x{columnsB} cannot be multiplied"
                          ))
    for i in range(0, rowsA):
        for j in range(0, columnsB):
            C[i][j] += sum([
                            A[i][e]*B[e][j]
                            for e in range(0, columnsA)
                           ])
    return C


def _matTranspose(A):
    if not A:
        return A
    rowsA, columnsA = len(A), len(A[0])
    B = _zeroMatrix(columnsA, rowsA)
    for i in range(0, columnsA):
        for j in range(0, rowsA):
            B[i][j] += A[j][i]
    return B


def _matSolve(A, v):
    # returns the coefficients of a solution x to Ax = v
    extendedRows = len(A)
    if not A:
        return None
    extendedColumns = len(A[0]) + 1
    extendedMatrix = _zeroMatrix(extendedRows, extendedColumns)
    for i, row in enumerate(A):
        for j, val in enumerate(row):
            extendedMatrix[i][j] = val
    for i, val in enumerate(v):
        extendedMatrix[i][extendedColumns-1] = val
    reducedMatrix = _rowReduction(extendedMatrix)[0]
    coeffs = [0] * len(A[0])
    for i, row in enumerate(reducedMatrix):
        for j, val in enumerate(row[:-1]):  # search for non-zero lines
            if val != 0:  # found pivot in this line
                coeffs[j] = reducedMatrix[i][-1]
                break
    return coeffs


def _concatenateMatrices(A, B):
    # returns the matrix A extended to right by the matrix B
    if not A:
        return B
    if not B:
        return A
    rowsA, colsA = len(A), len(A[0])
    rowsB, colsB = len(B), len(B[0])
    if rowsA != rowsB:
        raise ValueError("Cannot concatenate matrix of diferent row sizes")
    C = _zeroMatrix(rowsA, colsA + colsB)
    for i, row in enumerate(A):
        for j, val in enumerate(row):
            C[i][j] = val
    for i, row in enumerate(B):
        for j, val in enumerate(row):
            C[i][j+colsA] = val
    return C


def _solveFromBase(orderedBase, v):
    # returns the coefficients to write v in the base given
    if not orderedBase:
        raise ValueError(f"{orderedBase} is empty")
    baseMatrix = _matTranspose(orderedBase)
    coeffs = [_matSolve(baseMatrix, v)[i]
              for i in range(0, len(orderedBase))]
    if all(c == 0 for c in coeffs) and not all(e == 0 for e in v):
        # Error, v was not in the subspace generated by orderedBase
        raise NotInSpanError(f"{v} not in the span of {orderedBase}")
    return coeffs


def _allUnique(x):
    seen = list()
    return not any(i in seen or seen.append(i) for i in x)


def _dotProduct(v, t):
    if len(v) != len(t):
        raise NotImplementedError
    return sum([v[i]*t[i] for i in range(0, len(v))])


def _allDistinctOrthogonal(elements):
    seen = []
    for v in elements:
        if all(x == 0 for x in v):
            return False
        if v in seen:
            return False
        for w in seen:
            if _dotProduct(v, w) != 0:
                return False
        seen.append(v)
    return True


def _isLD(elements):
    numCols = len(elements)
    if numCols == 0:
        return False
    elif numCols == 1:
        if all(x == 0 for x in elements[0]):
            return True
        return False
    numRows = len(elements[0])
    A = _matTranspose(elements.copy())
    if numCols > numRows:
        return True
    B, rank = _rowReduction(A)
    return not _allDistinctOrthogonal(_matTranspose(B))


def _zeroMatrix(n, m):
    return [[0] * m for i in range(0, n)]


def _findKernel(A):
    # inputs a matrix, returns a list of basis elements for the kernel
    if not A:
        return []
    elif not A[0]:
        return []
    rows = len(A[0])
    B, rank = _rowReduction(A)
    relationLines = []
    boundIndexes = {}
    for row in B:
        if not all(x == 0 for x in row):  # there is a pivot
            relationLines.append(row)
    for line, rel in enumerate(relationLines):
        pivot = next((i for i, x in enumerate(rel) if x), None)
        boundIndexes[line] = pivot
    freeIndexes = set(range(0, rows)) - set(boundIndexes.values())
    solutions = []
    for ind in freeIndexes:
        # create a free solution and apply the relation lines to it
        solution = [_delta(i, ind) for i in range(0, rows)]
        for lineInd in sorted(boundIndexes.keys(), key=int, reverse=True):
            pivot = boundIndexes[lineInd]
            solution[pivot] = -sum(map(
                                    op.mul,
                                    relationLines[lineInd][pivot+1:],
                                    solution[pivot+1:]))
        solutions.append(solution)
    return solutions


def _printMatrix(M):
    rows = len(M)
    if rows == 0:
        print("[]")
        return
    columns = len(M[0])
    namelens = []
    for row in M:
        namelens = namelens + [len(str(e)) for e in row]
    maxlen = max(namelens)
    lines = []
    for i in range(0, rows):
        line = []
        line.append('| ')
        for j in range(0, columns):
            line.append(' ' + str(M[i][j]).rjust(maxlen, ' ') + ' ')
        line.append(' |')
        lines.append(''.join(line))
    print('\n'.join(lines))
