""" Base module for Lie Algebras and their elements

Main reference: W.A. de Graaf, "Lie Algebras: Theory and Algorithms",
henceforth referenced as [WAG]

Usage:
    You can give a FiniteTypeLieAlgebra explicitly by giving its dimension and
    a multiplication table. For instance, the non-abelian algebra of dimension
    2 is given as follows:
        >>> Sol = FiniteTypeLieAlgebra(
                dimension=2,
                structureConstants=[
                    [  # [A, ...]
                        [0, 0],  # [A, A] = 0
                        [1, 0]  # [A, B] = A
                    ],
                    [  # [B, ...]
                        [-1, 0],  # [B, A] = -A
                        [0, 0]  # [B, B] = 0
                    ]
                ]
            )
        >>> Sol.isAbelian()
        False
        >>> A = FiniteTypeLieAlgebraElement([1, 0], Sol)
        >>> A = FiniteTypeLieAlgebraElement([0, 1], Sol)
        >>> str(A*B)
        '(1, 0)'
        >>> A*B == A
        True

    Linear Lie algebras are also implemented. For instance, the Lie algebra GL2
    is given by:
        >>> GL2 = LinearLieAlgebra(lDimension=2)
        >>> E12 = GL2.E(1, 2)
        >>> E21 = GL2.E(2, 1)
        >>> print(E12*E21)
        |   1   0  |
        |   0  -1  |

    No assumption is made on the nature of the coefficients as long as they can
    be added, subtracted and multiplied (with a compatible Z-action as a
    abelian group). Using floats:
        >>> from math import pi, exp
        >>> print(pi*E12 + exp(1)*E21)
        |                0.0  3.141592653589793  |
        |  2.718281828459045                0.0  |
        >>> print((pi*E12)*(exp(1)*E21))
        |   8.539734222673566                 0.0  |
        |                 0.0  -8.539734222673566  |

    Using fractions:
        >>> from fractions import Fraction
        >>> print(Fraction(1, 3)*E12 + Fraction(3, 2)*E21)
        |    0  1/3  |
        |  3/2    0  |
        >>> print((Fraction(1, 3)*E12)*(Fraction(3, 2)*E21))
        |   1/2     0  |
        |     0  -1/2  |

    Using sympy literals:
        >>> from sympy import symbols, sin
        >>> x = symbols('x')
        >>> print((x**2 + 1)*E12 + (sin(x))*E21)
        |         0  x**2 + 1  |
        |    sin(x)         0  |
        >>> print(((x**2 + 1)*E12)*((sin(x))*E21))
        |   (x**2 + 1)*sin(x)                   0  |
        |                   0  -(x**2 + 1)*sin(x)  |

    We can construct subalgebras generated by any family of elements:
        >>> X, Y, H = E12, E21, GL2.E(1,1) - GL2.E(2,2)
        >>> SL2, i_SL2 = GL2.subalgebra([X, Y, H])
        >>> SL2.dimension
        3
        >>> i_SL2.isinjective()
        True
        >>> i_SL2.issurjective()
        False
    If we pass a linearly dependent set, it trims unecessary terms by poping
    the last ones in the list until the set becomes linearly independent.
        >>> SL2, i_SL2 = GL2.subalgebra([X, Y, H, X*Y])
        >>> SL2.dimension
        3
    The second argument return is a FiniteTypeLieAlgebraHomomorphism that
    allows one to go back and forth between elements of both algebras.
        >>> x, y, h = i_SL2.inverseImage(X), i_SL2.inverseImage(Y),
            i_SL2.inverseImage(H)
        >>> str(x)
        '(1.0, 0.0, 0.0)'
        >>> print(i_SL2.evaluate(x))
        |  0.0  1.0  |
        |  0.0  0.0  |
        >>> i_SL2.evaluate(x) == X
        True
    The conversion to float is a consequence of row reduction on the call to
    inverseImage. Moreover, compatible homomorphisms can be composed, so that
     f*g denotes the composition defined by x -> f(g(x)).
        >>> Bor, i_Bor = SL2.subalgebra([x, h])
        >>> Bor.dimension
        2
        >>> comp = i_SL2 * i_Bor
        >>> z = i_Bor.inverseImage(h)
        >>> print(comp.evaluate(z))
        |   1.0   0.0  |
        |   0.0  -1.0  |

    It can check wheter a subalgebra is an ideal.
        >>> ASol, i_ASol = Sol.subalgebra([A])
        >>> Sol.isIdeal(ASol, i_ASol)
        True
        >>> Sol.isIdeal(Sol.isIdeal(*Sol.subalgebra([B])))
        False
    It also can define the quotient algebra by an ideal and the quotient
    homomorphism.
        >>> SolModA, p_SolModA = Sol.quotientAlgebra(ASol, i_ASol)
        >>> SolModA.dimension
        1
        >>> p_SolModA.isinjective()
        False
        >>> p_SolModA.kernel()[0].dimension
        1
        >>> str(p_SolModA.kernelBasis[0])
        (1, 0)
        >>> p_SolModA.issurjective()
        True
        >>> Abar = SolModA.canonicalBasis()[0]
        >>> Abar
        (1,)
        >>> Abarpreim = p_SolModA.inverseImage(Abar)
        >>> Abarpreim
        (0, 1.0)
        >>> Abarpreim == B
        True
        >>> SolModB, p_SolModB = Sol.quotientAlgebra(*Sol.subalgebra([B]))
        ValueError: Subalgebra is not an ideal

    Calling adjointRepresentation on any type of FintieTypeLieAlgebra gives the
    homomorphism into the linear algebra over itself representing the adjoint
    map.
        >>> ad_SL2 = SL2.adjointRepresentation()
        >>> print(ad_SL2(x))
        |   0.0   0.0  -2.0  |
        |   0.0   0.0   0.0  |
        |   0.0   1.0   0.0  |
        >>> print(ad_SL2(h))
        |   2.0   0.0   0.0  |
        |   0.0  -2.0   0.0  |
        |   0.0   0.0   0.0  |
        >>> ad_Sol = Sol.adjointRepresentation()
        >>> print(ad_Sol(A))
        |  0  1  |
        |  0  0  |

    We can compute centralizers:
        >>> SubE12, E12_to_GL2 = GL2.subalgebra([E12])
        >>> C1, C1_to_GL2 = GL2.centralizer(SubE12, E12_to_GL2)
        >>> C1.dimension
        2
        >>> print(C1_to_GL2.imageBasis[0])
        |  0.0    1  |
        |  0.0    0  |
        >>> print(C1_to_GL2.imageBasis[1])
        |  1.0    0  |
        |  0.0    1  |
    and centers:
        >>> ZGL2, ZGL2_to_GL2 = GL2.center()
        >>> ZGL2.dimension
        1
        >>> print(ZGL2_to_GL2.imageBasis[0])

    We can check whether a homomorphism factors through a quotient, and get the
    induced map:
        >>> ZQuoAlg, ZQuoMap = GL2.quotientAlgebra(ZGL2, ZGL2_to_Gl2)
        >>> ad_GL2.factorsThroughQuotient(ZQuoAlg, ZQuoMap)
        True
        >>> ZAdFactor = ad_GL2.factorQuotient(ZQuoAlg, ZQuoMap)
        >>> ad_GL2 == ZAdFactor * ZQuoMap
        True
    The same to check if it factors into a subgroup:
        >>> SL4, i_SL4 = ad_GL2.codomain.SpecialLinear()
        >>> ad_GL2.factorsIntoSubalgebra(SL4, i_SL4)
        True
        >>> restrAd_GL2 = ad_GL2.factorInclusion(SL4, i_SL4)
        >>> ad_GL2 == i_SL4 * restrAd_GL2
        True

    Derived subalgebras are implemented:
        >>> SolLCS = Sol.lowerCentralSeries()
    We can check nilpotency by checking if the last term of SolLCS is zero:
        >>> SolLCS[-1][0].dimension == 0
        False

"""

import operator as op
from bracketpy._matrix_math_utils import (
    _delta,
    _matMult,
    _matTranspose,
    _matSolve,
    _solveFromBase,
    NotInSpanError,
    _isLD,
    _zeroMatrix,
    _findKernel
)
from tqdm import tqdm


_VERBOSE = False


class FiniteTypeLieAlgebraElement():
    """ An element of an abstract Lie algebra.

    The __init__ parameters should not be changed in subclasses, as it may
    break compatibility between operations.

    Attributes:
        coefficients holds it's coordinates in the canonical basis of
        parentAlgebra.
    """

    __slots__ = ('coefficients', 'parentAlgebra')

    def __init__(self, coefficients=None, parentAlgebra=None):
        self.coefficients = coefficients
        self.parentAlgebra = parentAlgebra

    def __getitem__(self, key):
        return self.coefficients[key]

    def __setitem__(self, key, value):
        self.coefficients[key] = value

    def __iter__(self):
        return iter(self.coefficients)

    def __eq__(self, other):
        if isinstance(other, FiniteTypeLieAlgebraElement):
            return (self.coefficients == other.coefficients)
        return False

    def __add__(self, other):
        if isinstance(other, FiniteTypeLieAlgebraElement):
            return self.__class__(
                coefficients=list(map(op.add, self, other)),
                parentAlgebra=self.parentAlgebra
            )
        return NotImplemented

    def __sub__(self, other):
        if isinstance(other, FiniteTypeLieAlgebraElement):
            return self.__class__(
                coefficients=list(map(op.sub, self, other)),
                parentAlgebra=self.parentAlgebra
            )
        return NotImplemented

    def __mul__(self, other):
        if isinstance(other, FiniteTypeLieAlgebraElement):
            if self.parentAlgebra != other.parentAlgebra:
                return NotImplemented
            dim = self.parentAlgebra.dimension
            coeffs = [0] * dim
            for k in range(0, dim):
                for i, a in enumerate(self.coefficients):
                    for j, b in enumerate(other.coefficients):
                        coeffs[k] += a*b \
                            * self.parentAlgebra.structureConstants[i][j][k]
            return self.__class__(
                coefficients=coeffs,
                parentAlgebra=self.parentAlgebra
            )
        return self.__class__(
            coefficients=[a*other for a in self],
            parentAlgebra=self.parentAlgebra
        )

    def __rmul__(self, other):
        if isinstance(other, FiniteTypeLieAlgebraElement):
            return -1*self*other
        return self*other

    def __truediv__(self, other):
        return self.__class__(
            coefficients=[a/other for a in self],
            parentAlgebra=self.parentAlgebra
        )

    def __floordiv__(self, other):
        return self.__class__(
            coefficients=[a//other for a in self],
            parentAlgebra=self.parentAlgebra
        )

    def __neg__(self):
        return self.__class__(
            coefficients=[-a for a in self],
            parentAlgebra=self.parentAlgebra
        )

    def __str__(self):
        return str(tuple(self.coefficients))

    def __bool__(self):
        return not all(x == 0 for x in self)

    def isMultiple(self, other):
        if not isinstance(other, FiniteTypeLieAlgebraElement):
            return False
        if not self:
            return True
        selfNonZeros = [i for i, e in enumerate(self) if e != 0]
        otherNonZeros = [i for i, e in enumerate(other) if e != 0]
        if selfNonZeros != otherNonZeros:
            return False
        k = self[selfNonZeros[0]]/other[otherNonZeros[0]]
        for i in selfNonZeros:
            if self[i]/other[i] != k:
                return False
        return True


class FiniteTypeLieAlgebra():
    """ Class for the most general type of finitely generated Lie algebra.

    The data model used is the one described in [WAG, p. 14, Structure
    Constants]. Hence, every general finite type Lie algebra is represented by
    it's dimension n as a vector space and its n³ list of structure constants,
    which is itself stored in the model structureConstants[i][j][k] for
    c_{ij}^k as in the book (i.e. c_{ij}^k is the k-th component of [ei, ej]
    where ei and ej are the i-th and j-th elements of the ordered canonical
    basis of "the" vector space of dimension n) Because of Python's dynamic
    type casting, we don't need to specify the base field at any moment.
    """

    __slots__ = ('dimension', 'structureConstants')

    ElemType = FiniteTypeLieAlgebraElement

    def __init__(self, dimension=0, structureConstants=[]):
        self.dimension = dimension
        self.structureConstants = structureConstants

    def __eq__(self, other):
        # badly implemented, checks for equality, not isomorphism.
        if not isinstance(other, FiniteTypeLieAlgebra):
            return False
        if self.dimension != other.dimension:
            return False
        if self.structureConstants != other.structureConstants:
            return False
        return True

    def canonicalBasis(self):
        # Simply returns a list of the n vectors of a canonical basis.
        # Subclasses may override this to ensure better element control.
        return [
            FiniteTypeLieAlgebraElement(
                coefficients=[
                    _delta(i, j) for j in range(0, self.dimension)
                ],
                parentAlgebra=self
            )
            for i in range(0, self.dimension)
        ]

    def subalgebra(self, orderedBase, verbose=_VERBOSE):
        # orderedBase must be a list of vectors, which will be reduced to a
        # base of the subspace that they generate
        # returns a tuple (alg, hom)
        # where alg is a FiniteTypeLieAlgebra representing the algebra
        # and hom is a FiniteTypeLieAlgebraHomomorphism representing the
        # inclusion map
        orderedBase = list(filter(bool, orderedBase))
        cleanList = []
        for A in orderedBase:
            cleanList.append(A)
            for B in cleanList[:-1]:
                if A.isMultiple(B):
                    cleanList.pop()
        orderedBase = cleanList
        baseCoeffs = [list(A) for A in orderedBase]
        while (_isLD(baseCoeffs)):
            baseCoeffs.pop()
            orderedBase.pop()
        subDimension = len(orderedBase)
        subStructureConstants = [
            [
                [] for j in range(0, subDimension)
            ] for i in range(0, subDimension)
        ]
        if verbose:
            pbar = tqdm(total=len(orderedBase)**2)
        for i, A in enumerate(orderedBase):
            for j, B in enumerate(orderedBase):
                subStructureConstants[i][j] = _solveFromBase(
                    [list(A) for A in orderedBase], A*B)
                if verbose:
                    pbar.update(1)
        if verbose:
            pbar.close()
        alg = FiniteTypeLieAlgebra(
            dimension=subDimension,
            structureConstants=subStructureConstants
        )
        hom = FiniteTypeLieAlgebraHomomorphism(
            domain=alg,
            codomain=self,
            matrix=_matTranspose([list(A) for A in orderedBase])
        )
        return (alg, hom)

    def _generateRelativeStructuralConstants(self, basis, verbose=_VERBOSE):
        # Gives a matrix of structural constants for some basis other than the
        # canonical one.
        relStructCons = [
            [
                [0]*self.dimension for f in range(0, self.dimension)
            ] for e in range(0, self.dimension)
        ]
        if verbose:
            pbar = tqdm(total=len(basis)**2)
        for i, A in enumerate(basis):
            for j, B in enumerate(basis):
                if i == j:
                    continue
                elif i < j:
                    relStructCons[i][j] = _solveFromBase(
                                            [list(A) for A in basis], A*B)
                else:
                    relStructCons[i][j] = [-val for val in relStructCons[j][i]]
                if verbose:
                    pbar.update(1)
        if verbose:
            pbar.close()
        return relStructCons

    def quotientAlgebra(self, subalgebra, inclusionHom, verify=True,
                        verbose=_VERBOSE):
        """ Generates the quotient algebra and quotient map given an ideal

        Described in [WAG, p. 16].

        Args:
            subalgebra is the ideal being quotiented out, inclusionHom is the
            homomorphism that allows this subalgebra to be identified with
            something living inside self. Verify is a bool that asks wheter or
            not we should enforce that subalgebra is an ideal - if turned off
            it may save performance, but the program may run unxepectedly if
            subalgebra is not a guaranteed ideal.

        Returns:
            A pair (alg, hom) where alg is the quotient algebra and hom is the
            quotient homomorphism.

        Raises:
            ValueError if verify==True and subalgebra is not an algebra.
        """
        # orderedBase must be a list of vectors, which will be reduced to a
        # base of the ideal that they generate
        # raises ValueError if is not ideal, unless verify is False!
        # returns a tuple (alg, hom)
        # where alg is a FiniteTypeLieAlgebra representing the quotient algebra
        # and hom is a FiniteTypeLieAlgebraHomomorphism representing the
        # quotient map
        basis = list(filter(bool, inclusionHom.imageBasis))
        if verify:
            if not self.isIdeal(subalgebra, inclusionHom):
                raise ValueError("Subalgebra is not an ideal")
        canonBasis = [e for e in self.canonicalBasis()]
        quotientBasis = basis.copy()
        for ind, e in enumerate(canonBasis):
            quotientBasis.append(e)
            baseCoeffs = [list(A) for A in quotientBasis]
            if _isLD(baseCoeffs):
                quotientBasis.pop()
        relativeStructure = \
            self._generateRelativeStructuralConstants(quotientBasis)
        kernelDim = len(basis)
        quotientDim = self.dimension - kernelDim
        quotientStructure = [
            [
                [0]*quotientDim for f in range(0, quotientDim)
            ] for e in range(0, quotientDim)
        ]
        for i in range(0, quotientDim):
            for j in range(0, quotientDim):
                for k in range(0, quotientDim):
                    quotientStructure[i][j][k] = \
                        relativeStructure[i+kernelDim][j+kernelDim][
                            k+kernelDim]
        quotientAlgebra = FiniteTypeLieAlgebra(
            dimension=quotientDim,
            structureConstants=quotientStructure
        )
        quotientMatrix = [
            [0]*self.dimension for i in range(0, quotientDim)
        ]
        for j, e in enumerate(self.canonicalBasis()):
            projection = _solveFromBase(
                            [list(A) for A in quotientBasis],
                            list(e))[kernelDim:]
            for i, val in enumerate(projection):
                quotientMatrix[i][j] = val
        quotientHom = FiniteTypeLieAlgebraHomomorphism(
            domain=self,
            codomain=quotientAlgebra,
            matrix=quotientMatrix,
        )
        return (quotientAlgebra, quotientHom)

    def isInSubalgebra(self, elem, subalgebra, inclusionHom):
        basis = inclusionHom.imageBasis
        try:
            _solveFromBase([list(A) for A in basis], elem)
        except NotInSpanError:
            return False
        return True

    def isIdeal(self, subalgebra, inclusionHom):
        basis = inclusionHom.imageBasis
        for A in self.canonicalBasis():
            for B in basis:
                if not self.isInSubalgebra(A*B, subalgebra, inclusionHom):
                    return False
        return True

    def adjointRepresentation(self):
        """ Returns a homomorphism to a linear Lie algebra given by it's
        adjoint representation on itself.

        Algorithm described in [WAG, p. 16]
        """
        endoAlgebra = LinearLieAlgebra(lDimension=self.dimension)
        adjointReprMatrix = _zeroMatrix(self.dimension**2, self.dimension)
        for m in range(0, self.dimension**2):
            k, j = divmod(m, self.dimension)
            for i in range(0, self.dimension):
                adjointReprMatrix[m][i] = self.structureConstants[i][k][j]
        return FiniteTypeLieAlgebraHomomorphism(
            domain=self,
            codomain=endoAlgebra,
            matrix=adjointReprMatrix
        )

    def isAbelian(self):
        for row in self.structureConstants:
            for column in row:
                for value in column:
                    if value != 0:
                        return False
        return True

    def centralizer(self, subalgebra, inclusionHom, verbose=_VERBOSE):
        """ Returns the centralizer and its inclusion into this algebra

        Described in [WAG, p. 17]
        """
        n = self.dimension
        subalgebraBase = inclusionHom.imageBasis
        t = subalgebra.dimension
        definingMatrix = _zeroMatrix(n*t, n)
        # crazy formula, but see page 17 on [WAG]
        for ell in range(0, t):
            for k in range(0, n):
                for i in range(0, n):
                    definingMatrix[n*ell + k][i] = \
                        sum([subalgebraBase[ell][j]
                             * self.structureConstants[i][j][k]
                            for j in range(0, n)])
        centralizerBasis = _findKernel(definingMatrix)
        return self.subalgebra(
            [self.__class__.ElemType(coefficients=v, parentAlgebra=self)
             for v in centralizerBasis],
            verbose=verbose
        )

    def center(self):
        return self.centralizer(self, self.identityMap())

    def identityMap(self):
        return FiniteTypeLieAlgebraHomomorphism(
            domain=self,
            codomain=self,
            matrix=[
                [_delta(i, j) for j in range(0, self.dimension)]
                for i in range(0, self.dimension)
            ]
        )

    def generatedBy(self, elements):
        for e in self.canonicalBasis():
            try:
                _solveFromBase(
                    [list(elem) for elem in elements],
                    list(e)
                )
            except NotInSpanError:
                return False
        return True

    def normalizer(self, subalgebra, inclusionHom, verbose=_VERBOSE):
        """ Returns the normalizer and its inclusion into this algebra

        Described in [WAG, p. 18]
        """
        n = self.dimension
        subalgebraBase = inclusionHom.imageBasis
        t = subalgebra.dimension
        definingMatrix = _zeroMatrix(n*t, n+t*t)
        # even crazier formula, but see page 18 on [WAG]
        for ell in range(0, t):
            for k in range(0, n):
                for i in range(0, n):
                    definingMatrix[n*ell + k][i] = \
                        sum([subalgebraBase[ell][j]
                             * self.structureConstants[i][j][k]
                            for j in range(0, n)])
                for m in range(0, t):
                    definingMatrix[n*ell + k][n + ell*t + m] = \
                        -subalgebraBase[m][k]
        normalizerBasis = [A[:n] for A in _findKernel(definingMatrix)]
        return self.subalgebra(
            [self.__class__.ElemType(coefficients=v, parentAlgebra=self)
             for v in normalizerBasis],
            verbose=verbose
        )

    def productSubalgebra(self, subalgebraA, inclusionA,
                          subalgebraB, inclusionB, verbose=_VERBOSE):
        """ For A, B subalgebras of self, calculates the subalgebra generated
        by [a,b] wtih a in A and b in B.

        Algorithm on [WAG, p. 20]

        Args:
            pairs subalgebraX, inclusionX to calculate the space. The same
            pairs can be generated using self.subalgebra([elements])

        Returns:
            a pair sub,incl where sub is the subalgebra [A,B] and incl is the
            canonical injective map [A,B] -> self
        """
        return self.subalgebra([
            a*b
            for a in inclusionA.imageBasis
            for b in inclusionB.imageBasis
            if a*b
        ], verbose=verbose)

    def derivedSubalgebra(self, verbose=_VERBOSE):
        # Returns the product subalgebra [self, self] and the inclusion map.
        iden = self.identityMap()
        return self.productSubalgebra(self, iden, self, iden, verbose=verbose)

    def lowerCentralSeries(self, verbose=_VERBOSE):
        """ Algorithm for return a finite list of terms for the lower central
        series.

        See [WAG, p. 20]

        Returns:
            A list containing each term of the lower central series, with the
            zeroth term being self. The series last term is non-zero iff the
            series dimensions stabilizes after that point.
        """
        lcSeries = [(self, self.identityMap())]
        nextTerm, nextHom = self.productSubalgebra(self, self.identityMap(),
                                                   self, self.identityMap(),
                                                   verbose=verbose)
        while nextTerm.dimension > 0:
            oldDim = nextTerm.dimension
            lcSeries.append((nextTerm, nextHom))
            nextTerm, nextHom = self.productSubalgebra(self,
                                                       self.identityMap(),
                                                       nextTerm, nextHom,
                                                       verbose=verbose)
            if oldDim == nextTerm.dimension:
                return lcSeries
        lcSeries.append((nextTerm, nextHom))
        return lcSeries

    def derivedSeries(self, verbose=_VERBOSE):
        """ Algorithm for return a finite list of terms for the derived series.

        See [WAG, p. 20]

        Returns:
            A list containing each term of the derived series, with the zeroth
            term being self. The series last term is non-zero iff the series
            dimensions stabilizes after that point.
        """
        derSeries = [(self, self.identityMap())]
        nextTerm, nextHom = self.productSubalgebra(self, self.identityMap(),
                                                   self, self.identityMap(),
                                                   verbose=verbose)
        while nextTerm.dimension > 0:
            oldDim = nextTerm.dimension
            derSeries.append((nextTerm, nextHom))
            nextTerm, nextHom = self.productSubalgebra(nextTerm, nextHom,
                                                       nextTerm, nextHom,
                                                       verbose=verbose)
            if oldDim == nextTerm.dimension:
                return derSeries
        derSeries.append((nextTerm, nextHom))
        return derSeries


class FiniteTypeLieAlgebraHomomorphism():
    """ The homomorphism allows us to relate Lie algebra elements defined
    over different spaces (or even different bases on the same space).

    Compatible homomorphisms can be composed with multiplicative notation.

    Attributes:
        domain and codomain are FiniteTypeLieAlgebra instances, and 'matrix' is
        the matrix that defines the linear transformation between both.
        imageBasis is calculated automatically upon instantiation.
    """

    __slots__ = ('domain',
                 'codomain',
                 'matrix',
                 'imageBasis',
                 'kernelBasis')

    def __init__(
        self,
        domain=None,
        codomain=None,
        matrix=None,
    ):
        self.domain = domain
        self.codomain = codomain
        self.matrix = matrix
        generatingSet = list(filter(bool, self._imageGenerators()))
        baseCoeffs = [list(A) for A in generatingSet]
        while _isLD(baseCoeffs):
            baseCoeffs.pop()
        self.imageBasis = generatingSet
        self.kernelBasis = self._calculateKernels()

    def evaluate(self, elem):
        coeffs = [v[0] for v in _matMult(self.matrix, [[val] for val in elem])]
        return self.codomain.__class__.ElemType(
            coefficients=coeffs,
            parentAlgebra=self.codomain
        )

    def e(self, elem):
        return self.evaluate(elem)

    def _imageGenerators(self):
        elems = []
        for j in range(0, self.domain.dimension):
            coeffs = []
            for i in range(0, self.codomain.dimension):
                coeffs.append(self.matrix[i][j])
            elems.append(
                self.codomain.__class__.ElemType(
                    coefficients=coeffs, parentAlgebra=self.codomain))
        return elems

    def __mul__(self, other):
        # implementa a composição self*other, avaliada como self(other(x))
        if not isinstance(other, FiniteTypeLieAlgebraHomomorphism):
            return NotImplemented
        if self.domain != other.codomain:
            raise ValueError("Can only compose maps with "
                             "compatible domain-codomain pair")
        return FiniteTypeLieAlgebraHomomorphism(
            domain=other.domain,
            codomain=self.codomain,
            matrix=_matMult(self.matrix, other.matrix)
        )

    def inverseImage(self, elem):
        coeffs = _matSolve(self.matrix, list(elem))[:self.domain.dimension]
        return self.domain.__class__.ElemType(
            coefficients=coeffs,
            parentAlgebra=self.domain
        )

    def ie(self, elem):
        return self.inverseImage(elem)

    def __eq__(self, other):
        if not isinstance(other, FiniteTypeLieAlgebraHomomorphism):
            return False
        if self.domain != other.domain:
            return False
        if self.codomain != other.codomain:
            return False
        if self.matrix != other.matrix:
            return False
        return True

    def image(self, verbose=_VERBOSE):
        return self.codomain.subalgebra(self.imageBasis, verbose=verbose)

    def _calculateKernels(self):
        elems = []
        coeffList = _findKernel(self.matrix)
        for coeffs in coeffList:
            elems.append(
                self.domain.__class__.ElemType(
                    coefficients=coeffs,
                    parentAlgebra=self.domain
                ))
        return elems

    def kernel(self, verbose=_VERBOSE):
        return self.domain.subalgebra(self.kernelBasis, verbose=verbose)

    def isinjective(self):
        return not bool(self.kernelBasis)

    def issurjective(self):
        return self.codomain.generatedBy(self.imageBasis)

    def isisomorphism(self):
        return self.isinjective() and self.issurjective()

    def inducedIso(self, verbose=_VERBOSE):
        """ Implements the isomorphism theorem, giving a map from the quotient
        to the image.
        """
        quoAlg, quoMap = self.domain.quotientAlgebra(*self.kernel())
        imAlg, imMap = self.codomain.subalgebra(self.imageBasis,
                                                verbose=verbose)
        isoMatrix = _zeroMatrix(imAlg.dimension, quoAlg.dimension)
        for j, v in enumerate(quoAlg.canonicalBasis()):
            w = imMap.inverseImage(self.evaluate(quoMap.inverseImage(v)))
            for i, coef in enumerate(w):
                isoMatrix[i][j] = coef
        inducedIso = FiniteTypeLieAlgebraHomomorphism(
            domain=quoAlg,
            codomain=imAlg,
            matrix=isoMatrix
        )
        return (quoAlg, quoMap, imAlg, imMap, inducedIso)

    def factorsThroughQuotient(self, quotientAlgebra, quotientMap):
        if quotientMap.domain != self.domain:
            return False
        for elem in quotientMap.kernelBasis:
            if self.evaluate(elem):  # if has non-trivial image
                return False
        return True

    def factorQuotient(self, quotientAlgebra, quotientMap, verify=True):
        if verify:
            if not self.factorsThroughQuotient(quotientAlgebra, quotientMap):
                raise ValueError("Cannot factor given maps.")
        factorMatrix = [[0]*quotientAlgebra.dimension
                        for i in range(0, self.codomain.dimension)]
        for j, v in enumerate(quotientAlgebra.canonicalBasis()):
            w = self.evaluate(quotientMap.inverseImage(v))
            for i, coef in enumerate(w):
                factorMatrix[i][j] = coef
        return FiniteTypeLieAlgebraHomomorphism(
            domain=quotientAlgebra,
            codomain=self.codomain,
            matrix=factorMatrix
        )

    def factorsIntoSubalgebra(self, subalgebra, inclusion):
        if self.codomain != inclusion.codomain:
            return False
        for elem in self.imageBasis:
            # we exploit that inverse img is 0 if it fails to find one
            if not inclusion.inverseImage(elem):
                return False
        return True

    def factorInclusion(self, subalgebra, inclusion, verify=True):
        if verify:
            if not self.factorsIntoSubalgebra(subalgebra, inclusion):
                raise ValueError("Cannot factor given maps.")
        factorMatrix = [[0] * self.domain.dimension
                        for i in range(0, subalgebra.dimension)]
        for j, v in enumerate(self.domain.canonicalBasis()):
            w = self.evaluate(v)
            coeffs = _solveFromBase([list(A) for A in inclusion.imageBasis],
                                    list(w))
            for i, coef in enumerate(coeffs):
                factorMatrix[i][j] = coef
        return FiniteTypeLieAlgebraHomomorphism(
            domain=self.domain,
            codomain=subalgebra,
            matrix=factorMatrix
        )


class LinearLieAlgebraElement(FiniteTypeLieAlgebraElement):

    def __str__(self):
        n = self.parentAlgebra.lDimension
        maxlen = max([len(str(e)) for e in self])
        lines = []
        for i in range(0, n):
            line = []
            line.append('| ')
            for j in range(0, n):
                line.append(' ' + str(self[j*n + i]).rjust(maxlen, ' ') + ' ')
            line.append(' |')
            lines.append(''.join(line))
        return '\n'.join(lines)


class LinearLieAlgebra(FiniteTypeLieAlgebra):

    __slots__ = (
        'lDimension'
    )

    ElemType = LinearLieAlgebraElement

    def __init__(self, lDimension=0):
        super().__init__(dimension=lDimension**2, structureConstants=[])
        self.lDimension = lDimension
        self._generateLinearStructureConstants()

    def _generateLinearStructureConstants(self):
        n = self.lDimension
        indexPairs = [(i, j) for i in range(0, n) for j in range(0, n)]
        self.structureConstants = [
            [
                [0]*self.dimension for f in range(0, self.dimension)
            ] for e in range(0, self.dimension)
        ]
        for A in indexPairs:
            for B in indexPairs:
                a = A[0]*n + A[1]
                b = B[0]*n + B[1]
                self.structureConstants[a][b][A[0]*n + B[1]] += \
                    _delta(A[1], B[0])
                self.structureConstants[a][b][B[0]*n + A[1]] += \
                    -_delta(B[1], A[0])

    def E(self, i, j, mathNotation=True):
        # mathNotation indexes start in 1, not 0
        e = 1 if mathNotation else 0
        return LinearLieAlgebraElement(
            [_delta(self.lDimension*(j-e) + (i-e), k)
                for k in range(0, self.dimension)],
            self
        )

    def canonicalBasis(self):
        return [self.E(i, j, mathNotation=False)
                for j in range(0, self.lDimension)
                for i in range(0, self.lDimension)]

    def SpecialLinear(self, verbose=_VERBOSE):
        # returns the subalgebra of all traceless matrices and its inclusion
        # map
        traceless = []
        n = self.lDimension
        for j in range(0, n):
            for i in range(0, n):
                if j != i:
                    traceless.append(self.E(i, j, False))
                elif i != n-1:
                    traceless.append(self.E(i, i, False) - self.E(n, n))
        return self.subalgebra(traceless, verbose=verbose)
